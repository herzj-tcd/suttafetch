#!/usr/bin/env python3
"""
SuttaFetch
A command-line tool to fetch and display a random sutta from dhammatalks.org

Version: 1.0.0
Author: Jonathan Herz
License: MIT

Usage:
    ./suttafetch              # Fetch a random sutta
    ./suttafetch -w 100       # Set custom width
    ./suttafetch --no-url     # Hide the source URL
    ./suttafetch --no-color   # Disable colors
"""

import requests
from bs4 import BeautifulSoup, NavigableString
import sys
import textwrap
import argparse
import re
import os

__version__ = "1.0.0"


# ANSI color codes
class Colors:
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'
    SAFFRON = '\033[38;5;214m'  # Saffron/orange color
    ITALIC = '\033[3m'
    ITALIC_END = '\033[23m'
    END = '\033[0m'
    
    @staticmethod
    def disable():
        Colors.HEADER = ''
        Colors.BLUE = ''
        Colors.CYAN = ''
        Colors.GREEN = ''
        Colors.YELLOW = ''
        Colors.RED = ''
        Colors.BOLD = ''
        Colors.UNDERLINE = ''
        Colors.SAFFRON = ''
        Colors.ITALIC = ''
        Colors.ITALIC_END = ''
        Colors.END = ''


def get_random_sutta():
    """Fetch a random sutta from dhammatalks.org"""
    try:
        # The random_sutta.php redirects to a random sutta page
        response = requests.get('https://www.dhammatalks.org/random_sutta.php', 
                                allow_redirects=True, 
                                timeout=10)
        response.raise_for_status()
        return response
    except requests.RequestException as e:
        print(f"{Colors.RED}Error fetching sutta: {e}{Colors.END}", file=sys.stderr)
        print(f"\n{Colors.YELLOW}Note: If you're behind a proxy or firewall, you may need to configure", file=sys.stderr)
        print(f"your network settings or set HTTP_PROXY/HTTPS_PROXY environment variables.{Colors.END}", file=sys.stderr)
        sys.exit(1)


def _normalize(text):
    """Extract text and normalize whitespace, preserving spaces between inline elements."""
    return ' '.join(text.split())


def _extract_verse_stanzas(verse_div):
    """Extract stanzas from a <div class='verse'> element.

    Direct <p> children form the first stanza.
    Each <div class='verse-add'> child forms a subsequent stanza.
    Lines within a stanza are joined with newlines.
    """
    stanzas = []

    # First stanza: direct <p> children (not inside a nested div)
    first_lines = []
    for child in verse_div.children:
        if getattr(child, 'name', None) == 'p':
            text = _normalize(child.get_text())
            if text:
                first_lines.append(text)
        elif getattr(child, 'name', None) == 'div':
            break  # hit a verse-add, first stanza is done
    if first_lines:
        stanzas.append('\n'.join(first_lines))

    # Subsequent stanzas from verse-add divs
    for va in verse_div.find_all('div', class_='verse-add'):
        lines = []
        for p in va.find_all('p'):
            text = _normalize(p.get_text())
            if text:
                lines.append(text)
        if lines:
            stanzas.append('\n'.join(lines))

    return stanzas


def parse_sutta(html_content):
    """Parse the sutta HTML and extract relevant information"""
    soup = BeautifulSoup(html_content, 'html.parser')

    # Remove footnote links (e.g. <a href="#an4.89note01">1</a>)
    for a in soup.find_all('a', href=True):
        if 'note' in a['href'] and a.get_text(strip=True).isdigit():
            a.decompose()

    # Replace <i> and <em> tags with ANSI italic markers
    _ITALIC_START = '\x00IS\x00'
    _ITALIC_END = '\x00IE\x00'
    for tag in soup.find_all(['i', 'em']):
        tag.insert(0, NavigableString(_ITALIC_START))
        tag.append(NavigableString(_ITALIC_END))
        tag.unwrap()

    # Replace italic markers with ANSI codes, ensuring spaces around italic text
    def apply_italics(text):
        text = text.replace(_ITALIC_START, Colors.ITALIC).replace(_ITALIC_END, Colors.ITALIC_END)
        if Colors.ITALIC:
            text = re.sub(r'(\w)' + re.escape(Colors.ITALIC), r'\1 ' + Colors.ITALIC, text)
            text = re.sub(re.escape(Colors.ITALIC_END) + r'(\w)', Colors.ITALIC_END + r' \1', text)
        return text

    # Extract title
    title_elem = soup.find('h1')
    if title_elem:
        for br in title_elem.find_all('br'):
            br.replace_with('\n')
        lines = title_elem.get_text().split('\n')
        title = '\n'.join(' '.join(line.split()) for line in lines if line.strip())
    else:
        title = "Unknown Sutta"
    title = apply_italics(title)
    
    # Extract sutta reference (e.g., AN 4:89)
    breadcrumb = soup.select('ol.breadcrumb li')
    if len(breadcrumb) >= 3:
        sutta_ref = breadcrumb[-1].get_text(strip=True)
    else:
        sutta_ref = ""
    
    # Get the main content - looking for paragraphs after the title
    # The content is typically in <p> tags after the h1
    content_paragraphs = []

    # Find the main content area
    # The sutta text typically starts after the title
    main_content = soup.find('h1')
    if main_content:
        # Get all siblings after the h1
        in_intro = False
        for sibling in main_content.find_next_siblings():
            classes = sibling.get('class', [])

            # Stop at notes heading (end of sutta body)
            if sibling.name == 'h2' and 'Notes' in sibling.get_text():
                break

            # Track intro section (between <h2 class="intro"> and <p class="stars">)
            if sibling.name == 'h2' and 'intro' in classes:
                in_intro = True
                continue
            # Stars separator marks the end of intro material
            if sibling.name == 'p' and 'stars' in classes:
                in_intro = False
                content_paragraphs.append('* * *')
                continue

            # Skip translation notes
            if sibling.name == 'div' and 'note' in classes:
                continue

            # Skip non-intro section headers (e.g. "A. Body")
            if sibling.name == 'h2':
                continue

            # Plain paragraphs (no class, or itiSecPP = Iti prose sections)
            if sibling.name == 'p' and ('class' not in sibling.attrs or 'itiSecPP' in classes):
                text = _normalize(sibling.get_text())
                if text:
                    content_paragraphs.append(text)
            # Blockquotes which often contain the sutta text
            elif sibling.name == 'blockquote':
                for p in sibling.find_all('p'):
                    text = _normalize(p.get_text())
                    if text:
                        content_paragraphs.append(text)
            # Block divs contain quoted passages
            elif sibling.name == 'div' and 'block' in classes:
                for p in sibling.find_all('p'):
                    text = _normalize(p.get_text())
                    if text:
                        content_paragraphs.append(text)
            # Verse divs contain poem/verse stanzas
            elif sibling.name == 'div' and 'verse' in classes:
                stanzas = _extract_verse_stanzas(sibling)
                for stanza in stanzas:
                    content_paragraphs.append(stanza)
    
    # Get the URL
    url = soup.find('link', {'rel': 'canonical'})
    sutta_url = url['href'] if url else ""
    
    # Replace em dashes (—) with spaced em dashes for readability
    # Process line-by-line to preserve intentional newlines in verses
    def fix_dashes(text):
        lines = text.split('\n')
        lines = [' '.join(line.replace('—', ' — ').split()) for line in lines]
        return '\n'.join(lines)
    content_paragraphs = [fix_dashes(p) for p in content_paragraphs]

    content_paragraphs = [apply_italics(p) for p in content_paragraphs]

    return {
        'title': title,
        'reference': sutta_ref,
        'content': content_paragraphs,
        'url': sutta_url
    }


def format_terminal_width(text, width=80):
    """Format text to fit terminal width, preserving intentional line breaks"""
    wrapper = textwrap.TextWrapper(width=width)
    lines = text.split('\n')
    wrapped = [wrapper.fill(line) for line in lines]
    return '\n'.join(wrapped)


def display_sutta(sutta_data, width=80, show_url=True):
    """Display the sutta in a formatted way"""
    # Title in saffron
    title_text = f"{sutta_data['reference']}: {sutta_data['title']}"
    print(f"{Colors.BOLD}{Colors.SAFFRON}{format_terminal_width(title_text, width)}{Colors.END}")
    print()
    
    # Content
    for paragraph in sutta_data['content']:
        print(format_terminal_width(paragraph, width))
        print()
    
    # Footer with URL in bold
    if show_url and sutta_data['url']:
        print()
        print(f"{Colors.BOLD}Source: {sutta_data['url']}{Colors.END}")
        print(f"{Colors.BOLD}Translated from the Pāli by Ṭhānissaro Bhikkhu{Colors.END}")


def main():
    parser = argparse.ArgumentParser(
        description='Fetch and display a random sutta from dhammatalks.org',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s                    Fetch and display a random sutta
  %(prog)s -w 100             Use 100 character width
  %(prog)s --no-color         Disable colored output
  %(prog)s --no-url           Hide the source URL
        """
    )
    parser.add_argument('-w', '--width', 
                        type=int, 
                        default=80,
                        help='Terminal width for text wrapping (default: 80)')
    parser.add_argument('--no-url', 
                        action='store_true',
                        help='Hide the source URL')
    parser.add_argument('--no-color',
                        action='store_true',
                        help='Disable colored output')
    parser.add_argument('-v', '--version',
                        action='version',
                        version=f'%(prog)s {__version__}')
    
    args = parser.parse_args()
    
    # Disable colors if requested or if output is not a terminal
    if args.no_color or not sys.stdout.isatty():
        Colors.disable()
    
    # Fetch and display the sutta
    print(f"{Colors.YELLOW}Fetching random sutta from dhammatalks.org...{Colors.END}")
    print()
    
    response = get_random_sutta()
    sutta_data = parse_sutta(response.content)
    display_sutta(sutta_data, width=args.width, show_url=not args.no_url)


if __name__ == '__main__':
    main()
